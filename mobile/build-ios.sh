#!/bin/bash
set -e

# iOS Build & Upload Script for Smart Pantry
# Usage: ./build-ios.sh
# Uses the workspace/scheme generated by expo prebuild (from app.json slug/name).

cd "$(dirname "$0")"

echo "üîß Step 1: Running expo prebuild..."
npx expo prebuild --platform ios --clean

echo "üîß Step 1b: Pod install..."
(cd ios && pod install)

WORKSPACE_PATH=$(find ios -maxdepth 1 -name "*.xcworkspace" -print -quit)
if [ -z "$WORKSPACE_PATH" ]; then
    echo "‚ùå No .xcworkspace found in ios/"
    exit 1
fi
WORKSPACE_NAME=$(basename "$WORKSPACE_PATH" .xcworkspace)

# Scheme: must be the APP scheme (builds .app), not a lib like EXConstants. Exclude Pod/dependency schemes.
if command -v jq &>/dev/null; then
  SCHEMES_JSON=$(xcodebuild -list -workspace "$WORKSPACE_PATH" -json 2>/dev/null)
  # Schemes that are targets inside Pods ‚Äî must not archive these (they produce generic archive, no .app).
  EXCLUDE_SCHEMES='EXConstants|^Pods-|^React|^RCT|^DoubleConversion|^glog|^Folly|^hermes|^libevent'
  ALL_SCHEMES=$(echo "$SCHEMES_JSON" | jq -r '.workspace.schemes[]? // .project.schemes[]? // empty' 2>/dev/null)
  # Prefer scheme that exactly matches workspace name (e.g. SmartPantryAI), else first scheme not in exclude list.
  SCHEME=$(echo "$ALL_SCHEMES" | grep -Fx "$WORKSPACE_NAME" 2>/dev/null | head -1)
  if [ -z "$SCHEME" ]; then
    SCHEME=$(echo "$ALL_SCHEMES" | grep -vE "$EXCLUDE_SCHEMES" 2>/dev/null | head -1)
  fi
  if [ -z "$SCHEME" ]; then
    SCHEME="$WORKSPACE_NAME"
  fi
else
  SCHEME="$WORKSPACE_NAME"
fi
echo "Using scheme: $SCHEME (workspace: $WORKSPACE_NAME)"

echo "üîß Step 2: Disabling User Script Sandboxing..."
PROJECT_PATH="ios/${WORKSPACE_NAME}.xcodeproj/project.pbxproj"
if [ -f "$PROJECT_PATH" ]; then
    sed -i '' 's/ENABLE_USER_SCRIPT_SANDBOXING = YES/ENABLE_USER_SCRIPT_SANDBOXING = NO/g' "$PROJECT_PATH" 2>/dev/null || true
fi

# Option C (SO): Only the .app should be in the archive; libs/frameworks must have Skip Install=YES
# so Xcode produces an "app archive" not a "generic archive" (expected one of {}).
echo "üîß Step 2b: Skip Install=YES for Pods (so archive has only .app, not libs)..."
find ios -name "project.pbxproj" -path "*/Pods/*" -exec sed -i '' 's/SKIP_INSTALL = NO/SKIP_INSTALL = YES/g' {} \; 2>/dev/null || true

# Team: Aasim S Syed (K5A25879TB)
# Use distribution identity from keychain (name can be "Apple Distribution" or "iOS Distribution").
CODE_SIGN_IDENTITY_NAME="Apple Distribution"
FOUND=""
if command -v security &>/dev/null; then
  FOUND=$(security find-identity -v -p codesigning 2>/dev/null | grep "K5A25879TB" | grep -i distribution | head -1)
  if [ -n "$FOUND" ]; then
    CODE_SIGN_IDENTITY_NAME=$(echo "$FOUND" | sed -E 's/.*"([^"]+)".*/\1/')
    echo "Using identity from keychain: $CODE_SIGN_IDENTITY_NAME"
  fi
fi
if [ -n "${GITHUB_ACTIONS:-}" ] && [ -z "$FOUND" ]; then
  echo "::error::No distribution identity found for team K5A25879TB. Check BUILD_CERTIFICATE_BASE64 and P12 import."
  echo "Current codesigning identities:"
  security find-identity -v -p codesigning 2>/dev/null || true
  exit 1
fi

# Pin app target Release to Apple Distribution so Xcode does not look for legacy "iOS Distribution".
echo "üîß Step 2c: Setting CODE_SIGN_IDENTITY for app target Release..."
if [ -f "$PROJECT_PATH" ]; then
  # App target Release config ID from expo prebuild; insert CODE_SIGN_IDENTITY after DEVELOPMENT_TEAM in that block.
  sed -i '' '/13B07F951A680F5B00A75B9A/,/name = Release;/{
    /DEVELOPMENT_TEAM = K5A25879TB;/a\
				CODE_SIGN_IDENTITY = "Apple Distribution";
  }' "$PROJECT_PATH" 2>/dev/null || true
fi

echo "üì¶ Step 3: Building archive (workspace=$WORKSPACE_NAME, scheme=$SCHEME)..."
ARCHIVE_PATH="$HOME/Library/Developer/Xcode/Archives/$(date +%Y-%m-%d)/${WORKSPACE_NAME}-$(date +%H%M%S).xcarchive"
mkdir -p "$(dirname "$ARCHIVE_PATH")"

# Do not pass SKIP_INSTALL=NO (SO: can pull libs into archive ‚Üí generic archive ‚Üí expected one of {})
ARCHIVE_ARGS=(
    -workspace "$WORKSPACE_PATH"
    -scheme "$SCHEME"
    -configuration Release
    -destination "generic/platform=iOS"
    -archivePath "$ARCHIVE_PATH"
    CODE_SIGN_IDENTITY="$CODE_SIGN_IDENTITY_NAME"
    DEVELOPMENT_TEAM=K5A25879TB
)
if [ -n "${PROVISIONING_PROFILE_SPECIFIER:-}" ]; then
  ARCHIVE_ARGS+=(CODE_SIGN_STYLE=Manual PROVISIONING_PROFILE_SPECIFIER="$PROVISIONING_PROFILE_SPECIFIER")
else
  ARCHIVE_ARGS+=(CODE_SIGN_STYLE=Automatic)
fi
xcodebuild archive "${ARCHIVE_ARGS[@]}"

echo "‚úÖ Archive created: $ARCHIVE_PATH"

# Option B: Inspect archive (Products/Applications + Info.plist) to verify app archive vs generic
echo "--- Archive contents (Option B: verify app archive) ---"
ls -la "$ARCHIVE_PATH/Products/Applications/" 2>/dev/null || echo "No Products/Applications"
plutil -p "$ARCHIVE_PATH/Info.plist" 2>/dev/null | head -40 || true
if [ -f "$ARCHIVE_PATH/Info.plist" ]; then
  echo "ApplicationProperties: $(plutil -extract ApplicationProperties raw "$ARCHIVE_PATH/Info.plist" 2>/dev/null || echo 'missing')"
fi
echo "---"

echo "üì§ Step 4: Exporting for App Store..."
EXPORT_PATH="/tmp/${WORKSPACE_NAME}-export"
rm -rf "$EXPORT_PATH"

# Bundle ID for provisioningProfiles key
BUNDLE_ID="com.aasimsyed.smartpantry"

# Build ExportOptions.plist: method app-store, manual + provisioningProfiles when set.
# SO: some setups fail when teamID is in plist; we try without teamID first (add back if export fails for other reason).
rm -f /tmp/ExportOptions.plist
/usr/libexec/PlistBuddy /tmp/ExportOptions.plist -c "Add :method string app-store" -c "Add :uploadSymbols bool true"
if [ -n "${PROVISIONING_PROFILE_NAME:-}" ] || [ -n "${PROVISIONING_PROFILE_SPECIFIER:-}" ]; then
  PROFILE_VALUE="${PROVISIONING_PROFILE_NAME:-$PROVISIONING_PROFILE_SPECIFIER}"
  /usr/libexec/PlistBuddy /tmp/ExportOptions.plist -c "Add :signingStyle string manual" -c "Add :provisioningProfiles dict" -c "Add :provisioningProfiles:${BUNDLE_ID} string $PROFILE_VALUE"
else
  /usr/libexec/PlistBuddy /tmp/ExportOptions.plist -c "Add :signingStyle string automatic"
fi
# SO: some xcodebuild versions fail when teamID is in plist; omit teamID unless export fails for other reason

xcodebuild -exportArchive \
    -archivePath "$ARCHIVE_PATH" \
    -exportOptionsPlist /tmp/ExportOptions.plist \
    -exportPath "$EXPORT_PATH"

IPA_PATH=$(find "$EXPORT_PATH" -maxdepth 1 -name "*.ipa" -print -quit)
if [ -z "$IPA_PATH" ]; then
    echo "‚ö†Ô∏è  No .ipa found in $EXPORT_PATH"
    exit 1
fi

if [ -n "${APPLE_ID:-}" ] && [ -n "${APPLE_APP_SPECIFIC_PASSWORD:-}" ]; then
    echo "üì§ Step 5: Uploading to TestFlight..."
    xcrun altool --upload-app -f "$IPA_PATH" -t ios -u "$APPLE_ID" -p "$APPLE_APP_SPECIFIC_PASSWORD" --output-format json
    echo ""
    echo "üéâ Build uploaded to App Store Connect."
else
    echo "‚ÑπÔ∏è  Skipping upload (set APPLE_ID and APPLE_APP_SPECIFIC_PASSWORD to upload)."
    echo "   To upload manually: xcrun altool --upload-app -f \"$IPA_PATH\" -t ios -u YOUR_APPLE_ID -p YOUR_APP_SPECIFIC_PASSWORD"
fi

echo "üì± Check TestFlight in ~10-30 minutes for the new build."
echo "Archive: $ARCHIVE_PATH"
